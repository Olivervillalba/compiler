import createSourcemap from '../utils/create-sourcemap'
import getLineAndColumnByPosition from '../utils/get-line-and-column-by-position'
import getPreprocessorTypeByAttribute from '../utils/get-preprocessor-type-by-attribute'
import mergeOutputChunks from '../utils/merge-output-chunks'
import recastUtil from 'recast/lib/util'
import {execute as runPreprocessor} from '../preprocessors'
import splitStringByEOL from '../utils/split-string-by-EOL'

const CSS_WRAPPER_PREFIX = 'export const css = \''
const CSS_WRAPPER_POSTFIX = '\'\n'

/**
 * Wrap the generate css code
 * @param   { string } code - generated css
 * @returns { string } compiler output
 */
function wrapOutput(code) {
  return `${CSS_WRAPPER_PREFIX}${code}${CSS_WRAPPER_POSTFIX}`
}

/**
 * Preprocess the css code (scss, sass, stylus...)
 * @param   { string } preprocessorType - css preprocessor id
 * @param   { Object } options - options that will be passed to the compiler
 * @param   { RiotParser.nodeTypes.TEXT } cssNode - css node detected by the parser
 * @returns { Output } code and sourcemap generated by the preprocessor
 */
async function preprocess(preprocessorType, options, cssNode) {
  return await (preprocessorType ?
    runPreprocessor('css', preprocessorType, options, cssNode.text) :
    { code: cssNode.text }
  )
}

/**
 * Generate the sourcemap for the css output
 * @param   { string } source - the entire tag source code
 * @param   { Object } cssNode - css node detected by the parser
 * @param   { string } file - source file path
 * @param   { number } options.line - output line
 * @param   { number } options.column - output column
 * @returns { SourceMapGenerator } a sourcemap instance
 */
function generateSourcemap(source, cssNode, file, { line, column }) {
  const sourcemap = createSourcemap({
    file
  })

  // pointer to mark the current parsing position
  // of the generated vs the original code
  const pointer = {
    generatedPosition: column,
    originalPosition: cssNode.start
  }

  splitStringByEOL(cssNode.text).forEach(row => {
    const charsLength = row.length
    const newColumnOffset = pointer.generatedPosition + charsLength

    sourcemap.addMapping({
      source: file,
      name: 'css',
      // the generated code will be always on the same line here
      // we keep adding the chars length to the columns here
      generated: {
        line,
        column: newColumnOffset
      },
      original: getLineAndColumnByPosition(source, newColumnOffset)
    })

    pointer.generatedPosition = newColumnOffset
  })

  return sourcemap
}

/**
 * Generate the component css
 * @param   { Object } sourceNode - node generated by the riot compiler
 * @param   { string } source - original component source code
 * @param   { Object } options - user options
 * @param   { Output } output - current compiler output
 * @returns { Promise<Output> } - enhanced output with the result of the current generator
 */
export default async function css(sourceNode, source, options, { code, map }) {
  const preprocessorType = getPreprocessorTypeByAttribute(sourceNode)
  const cssNode = sourceNode.text
  const sourcemap = generateSourcemap(source, cssNode, options.file, {
    line: splitStringByEOL(code).length,
    column: CSS_WRAPPER_PREFIX.length
  })

  const preprocessorOutput = await preprocess(preprocessorType, options, cssNode)


  const output = {
    code: wrapOutput(preprocessorOutput.code),
    map: preprocessorOutput.map ?
      recastUtil.composeSourceMaps(sourcemap, preprocessorOutput.map) :
      sourcemap
  }

  return mergeOutputChunks(output, { code, map })
}