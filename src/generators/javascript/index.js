import compose from '../../utils/compose'
import getPreprocessorTypeByAttribute from '../../utils/get-preprocessor-type-by-attribute'
import mergeOutputChunks from '../../utils/merge-output-chunks'
import preprocess from '../../utils/preprocess-node'
import recast from 'recast'

const { types } = recast
const { builders, namedTypes } = types

/**
 * Find all the import statements
 * @param   { Array } body - tree structure containing the program code
 * @returns { Array } array containing only the import statements
 */
function filterImportStatements(body) {
  return body.filter(node => namedTypes.ImportDeclaration.check(node))
}

/**
 * Find all the code in an ast program except for the import statements
 * @param   { Array } body - tree structure containing the program code
 * @returns { Array } array containing all the program code except the import expressions
 */
function filterNonImportstatements(body) {
  return body.filter(node => !namedTypes.ImportDeclaration.check(node))
}

/**
 * Get the body of the AST structure
 * @param   { Object } ast - ast object generated by recast
 * @returns { Array } array containing the program code
 */
function getProgramBody(ast) {
  return ast.program.body
}

/**
 * Remap the content of an ast converting the default export declaration into a return statement
 * @param   { Array } body - tree structure containing the program code
 * @returns { Array } the body remapped containing the return statement
 */
function transformExportDefaultIntoReturn(body) {
  return body.map(node => {
    if (namedTypes.ExportDefaultDeclaration.check(node))
      return builders.returnStatement(node.declaration)

    return node
  })
}

/**
 * Move the return statement at the end of the body
 * @param   { Array } body - tree structure containing the program code
 * @returns { Array } the body having the return decalration as last child
 */
function sortReturnStatement(body) {
  return body.sort(a => {
    if (namedTypes.ReturnStatement.check(a)) return 1
    return 0
  })
}

/**
 * Generate the component javascript logic
 * @param   { Object } sourceNode - node generated by the riot compiler
 * @param   { string } source - original component source code
 * @param   { Object } options - user options
 * @param   { Output } output - current compiler output
 * @returns { Promise<Output> } - enhanced output with the result of the current generator
 */
export default async function javascript(sourceNode, source, options, { code, map }) {
  const preprocessorName = getPreprocessorTypeByAttribute(sourceNode)
  const javascriptNode = sourceNode.text
  const preprocessorOutput = await preprocess('js', preprocessorName, options, source, javascriptNode)
  const sourceAST = recast.parse(preprocessorOutput.code)
  const sourceAstBody = getProgramBody(sourceAST)
  const importStatements = filterImportStatements(sourceAstBody)
  const tagSourceCode = compose(
    sortReturnStatement,
    transformExportDefaultIntoReturn,
    filterNonImportstatements
  )(sourceAstBody)

  // export default (function tag() { /* tag logic here * / })();
  const outputAST = builders.program([
    ...importStatements,
    builders.exportDefaultDeclaration(
      builders.callExpression(
        builders.functionExpression(
          builders.identifier('tag'), [],
          builders.blockStatement(tagSourceCode)
        ),
        []
      )
    )
  ])

  return mergeOutputChunks(recast.prettyPrint(outputAST), { code, map })
}