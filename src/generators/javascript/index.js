import compose from '../../utils/compose'
import composeSourcemaps from '../../utils/compose-sourcemaps'
import getPreprocessorTypeByAttribute from '../../utils/get-preprocessor-type-by-attribute'
import preprocess from '../../utils/preprocess-node'
import recast from 'recast'

const { types } = recast
const { builders, namedTypes } = types

// true if a node is an import statement
const isImportStatement = namedTypes.ImportDeclaration.check

/**
 * Find all the import statements
 * @param   { Array } body - tree structure containing the program code
 * @returns { Array } array containing only the import statements
 */
function filterImportStatements(body) {
  return body.filter(isImportStatement)
}

/**
 * Find all the code in an ast program except for the import statements
 * @param   { Array } body - tree structure containing the program code
 * @returns { Array } array containing all the program code except the import expressions
 */
function filterNonImportstatements(body) {
  return body.filter(node => !isImportStatement(node))
}

/**
 * Get the body of the AST structure
 * @param   { Object } ast - ast object generated by recast
 * @returns { Array } array containing the program code
 */
function getProgramBody(ast) {
  return ast.program.body
}

/**
 * Remap the content of an ast converting the default export declaration into a return statement
 * @param   { Array } body - tree structure containing the program code
 * @returns { Array } the body remapped containing the return statement
 */
function transformExportDefaultIntoReturn(body) {
  return body.map(node => {
    if (namedTypes.ExportDefaultDeclaration.check(node))
      return builders.returnStatement(node.declaration)

    return node
  })
}

/**
 * Move the return statement at the end of the body
 * @param   { Array } body - tree structure containing the program code
 * @returns { Array } the body having the return decalration as last child
 */
function sortReturnStatement(body) {
  return body.sort(a => {
    if (namedTypes.ReturnStatement.check(a)) return 1
    return 0
  })
}

/**
 * Extend the AST adding the new tag method containing our tag sourcecode
 * @param   { Object } ast - current output ast
 * @param   { Object } sourceAST - tag ast source code
 * @returns { Object } the output ast extended containing the tag sourcecode
 */
function extendTagProperty(ast, sourceAST) {
  types.visit(ast, {
    visitProperty(path) {
      if (path.value.key.name === 'tag') {
        path.value.value = builders.functionExpression(
          null, [],
          builders.blockStatement(sourceAST)
        )
        path.value.method = true

        return false
      }

      this.traverse(path)
    }
  })

  return ast
}

/**
 * Generate the component javascript logic
 * @param   { Object } sourceNode - node generated by the riot compiler
 * @param   { string } source - original component source code
 * @param   { Object } options - user options
 * @param   { Output } output - current compiler output
 * @returns { Promise<Output> } - enhanced output with the result of the current generator
 */
export default async function javascript(sourceNode, source, options, { ast, map }) {
  const preprocessorName = getPreprocessorTypeByAttribute(sourceNode)
  const javascriptNode = sourceNode.text
  const preprocessorOutput = await preprocess('js', preprocessorName, options, source, javascriptNode)
  const generatedAst = recast.parse(preprocessorOutput.code, {
    inputSourceMap: composeSourcemaps(map, preprocessorOutput.map)
  })
  const generatedAstBody = getProgramBody(generatedAst)
  const importStatements = filterImportStatements(generatedAstBody)
  const tagSourceCode = compose(
    sortReturnStatement,
    transformExportDefaultIntoReturn,
    filterNonImportstatements
  )(generatedAstBody)

  const outputAst = builders.program([
    ...importStatements,
    ...compose(getProgramBody, extendTagProperty)(ast, tagSourceCode)
  ])

  return {
    ast: outputAst,
    map,
    code: recast.print(outputAst).code
  }
}