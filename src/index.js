import { SourceMapGenerator } from 'source-map'
/*import templateGenerator from './generators/template'
import javascriptGenerator from './generators/javascript'
import cssGenerator from './generators/css'*/
import { tagParser } from 'riot-parser'

// Riot tags fragments regex
const SCRIPT = /<script(\s+[^>]*)?>\n?([\S\s]*?)<\/script\s*>/gi
const STYLE = /<style(\s+[^>]*)?>\n?([\S\s]*?)<\/style\s*>/gi
const TYPE_ATTR = /\stype\s*=\s*(?:(['"])(.+?)\1|(\S+))/i

/**
 * Parsers that can be registered by users to preparse components fragments
 * @type { Object }
 */
const parsers = {
  javascript: {},
  css: {},
  template: {}
}

/**
 * Create the sourcemap instance
 * @param   { String } source - source file
 * @param   { String } code - original code
 * @param   { String } generated - generated file
 * @returns { SourceMapGenerator } a SourceMapGenerator instance
 */
export function sourcemap(source, code, generated) {
  const map = new SourceMapGenerator({ file: generated })
  map.setSourceContent(source, code)
  return map
}

/**
 * Get a fragment single fragment
 * @param   { String } source - source code of the tag we will need to compile
 * @param   { RegExp } regExp - regular expression used to find the fragment
 * @returns { Object } output
 * @returns { String } output.type - the "type" attribute used on the current fragment
 * @returns { String } output.code - the code contained in this fragment
 */
export function fragment(source, regExp) {
  const match = source ? regExp.exec(source) : null
  return match ? {
    // get the type="whathever" attribute
    type: match[1] ? TYPE_ATTR.exec(match[1])[2] : null,
    code: match[2]
  } : null
}

/**
 * Preparse the template source
 * @param   { Function } preparser - preparser function used to generate valid html
 * @param   { String } source - component source code
 * @returns { Promise } output - the result of the preparser
 */
export function preparse(preparser, source) {
  return Promise.resolve(preparser ? preparser(source) : source)
}

/**
 * Generate the js output from the parsing result
 * @param   { String } name - the component name
 * @param   { Object } fragments - fragments to build our output
 * @param   { Object } fragments.template - the template sub fragments
 * @param   { Object } fragments.javascript - the javascript public and private part
 * @param   { String } fragments.css - component syles
 * @param   { SourceMapGenerator } map - SourceMapGenerator instance
 * @returns { Object } output - result generated by the compiler
 * @returns { String } output.code - component code
 * @returns {  } output.code - component code
 */
export function generate(name, {template, javascript, css}, map) {
  return {
    code: `export default riot.define('${name}')`,
    map
  }
}

/**
 * Normalise the source code preparsing the javascript and the css in its contained
 * @param   { String } source - original source code
 * @returns { Promise } - source code normalised
 */
export function normalise(source) {
  // detect and cache the component fragments
  const fragments = [
    ['css', fragment(source, STYLE)],
    ['javascript', fragment(source, SCRIPT)]
  ]

  // preparse all the fragments if a prepareser was defined
  // otherwise return their code as it is
  return Promise.all(fragments
    .map(([type, fragment]) => {
      if (fragment) return preparse(parsers[type][fragment.type], fragment.code)
      // return an empty string if no fragment was found
      return Promise.resolve('')
    }))
    .then(results => {
      // remap the source code replacing the fragments code
      // with the output of the preparsing
      return {
        code: results.reduce((output, generated, index) => {
          const [, fragment] = fragments[index]
          if (fragment) output.replace(fragment.code, generated)
          return output
        }, source),
        fragments: results
      }
    })
}

/**
 * Register a custom user preparser
 * @param   { String } type - parser type either 'js', 'css' or 'template'
 * @param   { String } name - unique parser id
 * @param   { Function } parser - parser function
 * @returns { Function } - the parser function installed
 */
export function register(name, type, parser) {
  if (!type) throw 'Please define the type of parser you want to use \'javascript\', \'css\' or \'template\''
  if (!name) throw 'Please define a name for your parser'
  if (!parser) throw 'Please define your parser function'
  if (parsers[type][name]) throw `The parser ${name} was already registered`
  parsers[type][name] = parser
  return parser
}

/**
 * Generate the output code source together with the sourcemap
 * @param   { String } source - source code of the tag we will need to compile
 * @returns { String } output.code
 * @returns { String } output.map
 * @returns { String } output.fragments
 */
export function compile(source, options = {}) {
  return preparse(parsers.template[options.template], source)
    .then(normalise)
    .then(({ code }) => {
      const parser = tagParser({ brackets: ['{', '}'] })
      const { output } = parser.parse(code)
      const map = options.src && options.dist ? sourcemap(options.src, code, options.dist) : ''
      return generate(output.html.name, output, map)
    })
}